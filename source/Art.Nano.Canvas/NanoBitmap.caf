import &StandardImport, &Tools, {} &compositeModes

##
  Design Notes

  Q/A:
    Q: Why not make calls directly on the HTMLCanvas 2D Context?
    A: Because we need a layer of abstraction for:
      - draw-area detection
      - animation
      We run the same draw-function with the drawAreaDetector for the
      target to get the exact area of the pixels that will be altered.

      For animation, we'll run the function twice with the before and
      after parameters. That will create a draw-queue, which will be
      interpolated according to the animators rules.

class NanoBitmap extends BaseClass

  constructor: (a, b)->

    @size = nanoPoint 0
    @_htmlImageElement = @_canvas = null

    switch
    when isNumber b       then @_initNewCanvas a, b
    when isImage  a       then @_initFromImage a
    when isCanvas a       then @_initFromCanvas a, b
    when a is NanoBitmap  then @_initClone a

  @setter
    size: (obj) ->
      @_size_x = obj.x
      @_size_y = obj.y

  ###########################
    ToPerfTest
  ###########################
  setWithNanoPoint:    (x, y) -> @size = nanoPoint x, y
  setWithoutNanoPoint: (x, y) ->
    @_size_x = x
    @_size_y = y

  ###########################
    Initializers
  ###########################
  _initNewCanvas: (x, y) ->
    {x, y} = nanoPointFloor x, y

    unless nanoPointGt x, y, 0, 0
      throw new Error "invalid size=(#{x}, #{y}) for Art.Nano.Canvas.Bitmap"

    @_initFromCanvas newCanvas x, y

  _initFromCanvas: (canvas, contextAttributes) ->
    @_canvas = canvas
    @size = nanoPoint
      @_canvas.width
      @_canvas.height

    @_initContext contextAttributes

  _initFromImage: (image) ->
    @size = nanoPoint
      image.naturalWidth  ? image.width
      image.naturalHeight ? image.height

    @_htmlImageElement = image

  # override for WebGL
  _initContext: (contextAttributes)->
    @_context = @_canvas?.getContext "2d", contextAttributes

  ###########################
    Operations
  ###########################

  # Draw pixels
  fill:   -> @_context.fill()
  stroke: -> @_context.stroke()

  ##  Although drawImage has other params, I'd like to let
      the transform/matrix handle translation and scaling.
      As-for source-area options, I'll add them if needed.

      As-for drawBitmapWithLayout, I think I'll add functions
      for setting the matrix correctly for the various
      layout options.
      In fact, I'll probably make those utilities - so
      even ArtReact can use them. We'll need that option
      when we implement multi-touch zoom and pan.
  drawBitmap: (bitmap) -> @_context.drawImage bitmap, 0, 0

  # SET LINE PROPS
  :opSetLineWidth
  :opLineCap
  :opLineJoin

  # COMPISITE DRAW PROPS
  setCompositeMode: (compositeMode) ->
    @_context.globalCompositeOperation = compositeModes[compositeMode] || compositeModes.normal

  :opSetColor
  :opSetColors
  :opSetColorsWithPositions
  :opRepeatColors
  :opSetTo
  :opSetFrom
  :opSetRadial
  setShadow: (@_shadowOffset_x, @_shadowOffset_y, @_shadowBlur, @_shadowColor) ->

  prepareDraw: ->
    {_context} = @
    if @_shadowColor?
      ###
        Shadows seem to ignore scale and rotation transformations.

        It seems someone wanted to enforce consistent shadows while completely breaking
        the setTransform abstraction. Bah! :)

        I believe this was a design mistake. It introduces inconsistencies both subtle
        and large. For example, it makes shadow placement vary across devices depending
        upon their devicePixelsPerPoint. No other draw command works this way.

        Consistent shadows should be up to the programmer, not the drawing engine.

        I believe this hack solves the problem. Shadow SHAPE does obey setTransforms. It
        is also correctly proporitonal to the shape it is creating a shadow of. Said shape
        fully obeys setTrasform - including location. Only the vector from the center of
        the shape to the center of the shadow seems to ignore setTransform.
         - July 2016, SBD

      _context.shadowColor    = @_shadowColor
      _context.shadowBlur     = @_shadowBlur
      {x, y} = nanoMatrixTranslate @_matrix_xx, @_matrix_yy, @_matrix_xy, @_matrix_yx, @_matrix_x1, @_matrix_y1, @_shadowOffset_x, @_shadowOffset_y
      _context.shadowOffsetX  = x
      _context.shadowOffsetY  = y

  # :opResetShape # same as opRectangle
  resetStyle: ->
    {_context} = @

    _context.lineWidth  = 1
    _context.lineCap    = "butt"
    _context.lineJoin   = "miter"
    _context.miterLimit = 10

    # if compositeMode && compositeMode != "normal"
    _context.globalCompositeOperation = compositeModes.normal

    # if opacity < 1
    _context.globalAlpha = 1

    if @_shadowColor?
      _context.shadowColor = "transparent"
      @_shadowColor = null
      @_shadowBlur = _context.shadowBlur = 0
      @_shadowOffset_x = _context.shadowOffsetX = 0
      @_shadowOffset_y = _context.shadowOffsetY = 0


  # RESETS
  reset: ->
    @resetClip()
    @resetMatrix()
    @resetArea()

  # CLIPPING
  clip: ->
    @resetClip()
    @_context.clip()
    @_clipping = true

  resetClip: ->
    if @_clipping
      @_context.restore()
      @_clipping = false

  # MATRIX
  translate:  (x, y)  ->
    @matrix = nanoMatrixTranslate x, y  # required because HTMLCanvas doesn't transform shadows
    @_context.translate x, y

  rotate:     (angle) ->
    @matrix = nanoMatrixRotate angle    # required because HTMLCanvas doesn't transform shadows
    @_context.rotate angle

  scale:      (x, y)  ->
    @matrix = nanoMatrixScale x, y      # required because HTMLCanvas doesn't transform shadows
    @_context.scale x, y

  # text

  # SHAPE
  ##
    Notes on DrawArea and Shapes:
    For simplicity, we'll assume any shape's drawArea is a subset of @area.
    You can change @area ahead of time, but when you call @fill() or @stroke(),
    the path should be fully within the current @area - for that is the value
    which will be unioned with the current drawArea.

    If using @stroke, lineWidth and lineJoin and lineCap options will be taken
    into account. The resulting altered pixels can go outside @area - as long
    as the path is fully within.

  beginPath:            -> @_context.beginPath()
  closePath:            -> @_context.closePath()
  pathMoveTo:           (x, y) -> @_context.pathMoveTo x, y
  pathLineTo:           (x, y) -> @_context.pathLineTo x, y
  pathQuadraticCurveTo: (cp_x, cp_y, to_x, to_y) -> @_context.pathQuadraticCurveTo cp_x, cp_y, to_x, to_y
  pathBezierCurveTo:    (cp1_x, cp1_y, cp2_x, cp2_y, to_x, to_y) -> @_context.pathBezierCurveTo cp1_x, cp1_y, cp2_x, cp2_y, to_x, to_y
  pathArtTo:            (p1_x, p1_y, p2_x, p2_y, radius) -> @_context.pathArtTo p1_x, p1_y, p2_x, p2_y, radius
  pathArc:              (x, y, radius, startAngle, endAngle, counterClockwise) -> @_context.arc x, y, radius, startAngle, endAngle, counterClockwise
  pathRect:             (x, y, w, h) -> @_context.rect x, y, w, h

  # Reset to Basic Shapes
  # rectangle:
  # circle:
  # curvedRectangle:

  setArea: (@_area_x, @_area_y, @_area_w, @_area_h) ->

  resetArea: ->
    @setArea @_baseArea_x, @_baseArea_y, @_baseArea_w, @_baseArea_h

  setMatrix: (xx, yy, xy, yx, x1, y1) ->
    {xx, yy, xy, yx, x1, y1} = @matrix = nanoMatrixMul
      @_baseMatrix_xx
      @_baseMatrix_yy
      @_baseMatrix_xy
      @_baseMatrix_yx
      @_baseMatrix_x1
      @_baseMatrix_y1
      xx
      yy
      xy
      yx
      x1
      y1

    @_context.setTransform
      xx
      yy
      xy
      yx
      x1
      y1

  resetMatrix: ->
    @_context.setTransform
      @_baseMatrix_xx
      @_baseMatrix_xy
      @_baseMatrix_yx
      @_baseMatrix_yy
      @_baseMatrix_x1
      @_baseMatrix_y1

  setBaseArea: (@_baseArea_x, @_baseArea_y, @_baseArea_w, @_baseArea_h) ->
    @resetArea()

  setBaseMatrix: (@_baseMatrix_xx, @_baseMatrix_yy, @_baseMatrix_xy, @_baseMatrix_yx, @_baseMatrix_x1, @_baseMatrix_y1) ->
    @resetMatrix()

##
  IN:
    element: Art.Nano.Engine.Element
      Included so you can call:
        drawBitmap: ->
          draws the Element's bitmap.

        drawText: ->
          draws the Element's text.

        drawChild: (childKeyString) ->
          draws the specified child

        drawRemainingChildren: () ->
          draws any children not drawn by drawChild()
          If drawRemainingChildren is never called, it will
          be called after the funciton completes.
          If called again, noop.

        I.e. - every child will be drawn exactly once, you can
          just change the order.

  (target, parentSize, sourceBitmap, element) ->
    area = rect parentSize

